Парсит указанный файл записи ответов сервера на отдельные ответы.
Для каждого ответа определяет его тип, размер, формат сжатия и тело ответа.
Если в теле пресутсвуют timestamp текущего (в момент ответа) времени, находит его и определяет время ответа.
Так же выводит статистику по типу запроса: кол-во и средний размер.

Как использовать:
Запустить приложение, указав в параметрах запуска аргументы:
1) команда приложения: одна из 4 на выбор: parse|info|printall|save
2) путь до файла
Функционал команд:
parse:
Парсит файл.
Выводит кол-во блоков и краткую информацию о каждом из них.
info:
Парсит файл.
Выводит список типов поученных ответов, выстроенных по кол-ву. Для каждого типа выводит средний размер расжатого ответа.
Так же выводит время сессии, если было получено хотя бы 2 ответа с timestamp полями в теле.
printall:
Парсит файл.
Выводит полную информацию о кажом ответе.
save:
Парсит файл.
Сохраняет всю информацию о распаршеном файле в папке [path]_parsed.

Пример использования:
> tz parse dumps/dump1
> tz info dumps/dump2
> tz printall dumps/dump3
> tz save dumps/dump1

Структура протокола:
Файл записи разделён на сегменты, которые я назвал "блоки". Блоки не фиксированной длинны, первые 2 байта блока - little endian целое число, означающее длинну блока.
Следующие после длинны блока 2 байты я назвал "заголовок блока". Значение первого байта не определено, он всегда равен 0x08. Второй байт всегда совпадает с порядковым номером блока в записи.
Следующие после заголовка блока 11 байт я назвал "заголовок ответа". В некоторых нечастых случаях этот сегмент может быть 10 байт длинной. Полагаю, что в этом случае пропущен либо второй, либо третий байт. Значение заголовка ответа я определить не смог, но выявил несколько закономерностей внутри его структуры:
Первый байт всегда равен 0x1A
Четвёртый байт всегда равен 0x10
Последние 2 байта всегда равны 0x311A
Полагаю, что в данном сегменте должна храниться информация и коде ответа и времени получения запроса. Много раз пытался расшифровать этот сегмент, но из имеющихся байт ничего адекватного собрать не получилось.
Следующий после заголовка ответа 1 байт означает длину названия типа ответа (n).
Следующие n байт после длинны названия типа ответа - utf-8 строка, означающая название типа ответа.
Следующий байт после названия типа ответа всегда равен 0x22. Не знаю зачем он нужен.
Следующий после 0x22 1 байт означает длину названия алгоритма сжатия тела ответа (k).
Следующие k байт после длинны названия алгоритма сжатия тела ответа - utf-8 строка, означающая название алгоритма сжатия тела ответа.
Следующий байт после названия алгоритма сжатия тела ответа всегда равен 0x2A. Не знаю зачем он нужен.
На этом этапе происходит ветвление в зависимости от представленного алгоритма сжатия. Он может быть один из 2х - ZSTD или LZ4.
Если указан алгоритм ZSTD:
	Следующие после 0x2A 1 или 2 байта означают длину сжатого тела ответа. Не понял, каким образом я должен понять, один или два байта за это отвечают, поэтому для каждого ZSTD ответа я произвожу 2 попытки разжать тело.
	Следующие до конца ответа байты - сжатое алгоритмом ZSTD тело ответа.
Если указан алгоритм LZ4:
	Иногда, по неизвестным мне причинам, в ответе, указанном как сжатый алгоритмом LZ4, тело представлено без сжатия вообще. Посмотрев на имеющиеся ответы, понял, что это происходит только когда следующий бит после 0x2A равен 0x59.
	Если равен 0x59:
		Следующие после 0x59 4 байта - little endian целое число, означающее длину разжатого тела ответа.
		Следующие после длинны разжатого тела ответа 4 байта - little endian целое число, означающее длину сжатого тела ответа.
		Так как в этом случае компрессии не производится, эти 2 целых числа будут равны.
		Следующие до конца ответа байты - не сжатое тело ответа.
	Если не равен 0x59:
		Следующие после 0x2A 2 байта могут быть разными в разных ответах, назначение не известно.
		Следующие 4 байта - little endian целое число, означающее длинну разжатого тела ответа.
		Следующие после длинны разжатого тела ответа 4 байта - little endian целое число, означающее длину сжатого тела ответа.
		Следующие до конца ответа байты - сжатое алгоритмом LZ4 тело ответа.
После этого блок может закончиться и начаться новый, но иногда вместо этого начинается новый заголовок ответа, в точности равный первому в блоке, а потом начинается новый ответ. Всё внутри того же самого блока. Сейчас я трактую это как несколько ответов внутри одного блока. Но выглядят эти ответы как дубликаты первого, так что может быть по факту это означает что-то другое.