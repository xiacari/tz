Парсит указанный файл записи ответов сервера на отдельные ответы.
Для каждого ответа определяет его время, тип, размер, формат сжатия и тело ответа.
Так же выводит статистику по типу запроса: кол-во и средний размер.

Как использовать:
Запустить приложение, указав в параметрах запуска аргументы:
1) команда приложения: одна из 4 на выбор: parse|info|printall|save
2) путь до файла
Функционал команд:
parse:
Парсит файл.
Выводит кол-во блоков и краткую информацию о каждом из них.
info:
Парсит файл.
Выводит список типов поученных ответов, выстроенных по кол-ву. Для каждого типа выводит средний размер расжатого ответа.
Так же выводит время сессии.
printall:
Парсит файл.
Выводит полную информацию о кажом ответе.
save:
Парсит файл.
Сохраняет всю информацию о распаршеном файле в папке [path]_parsed.

Пример использования:
> tz parse dumps/dump1
> tz info dumps/dump2
> tz printall dumps/dump3
> tz save dumps/dump1

Структура протокола:
Файл записи разделён на сегменты, которые я назвал "блоки". Блоки не фиксированной длинны, первые 2 байта блока - little endian целое число, означающее длинну блока.
Блок представлен в формате передачи данных "Protocol Buffers".
Схема:
	syntax = "proto3";
	message RawBlock {
  		int64 counter = 1;
  		repeated RawResponse responses = 3;
	}
	message RawResponse {
  		uint64 timestamp = 2;
  		string type = 3;
  		string compression = 4;
  		bytes content = 5;
	}
Поле content - тело ответа, сжатое одним из 2х фоматов: ZSTD или LZ4 
Иногда в ответе, указанном как сжатый алгоритмом LZ4, тело представлено без сжатия вообще.
После этого блок может закончиться и начаться новый, но иногда вместо этого начинается новый заголовок ответа, в точности равный первому в блоке, а потом начинается новый ответ. Всё внутри того же самого блока. Сейчас я трактую это как несколько ответов внутри одного блока. Но выглядят эти ответы как дубликаты первого.